<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor PDF Profesional</title>
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <!-- Fonts & Icons -->
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
        :root {
            --bg-dark: #0f172a;
            --bg-panel: #1e293b;
            --bg-paper: #ffffff;
            --text-light: #f8fafc;
            --text-dark: #0f172a;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --border: #334155;
            --ruler-bg: #f1f5f9;
            --ruler-text: #64748b;

            /* Dimensions */
            --a4-width-mm: 210;
            --a4-height-mm: 297;
            --mm-to-px: 3.7795275591;
            /* 96 DPI */
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-light);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- Toolbar --- */
        .toolbar {
            height: 60px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
            z-index: 50;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .brand {
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--accent);
            display: flex;
            align-items: center;
            gap: 10px;
            margin-right: 20px;
            text-decoration: none;
        }

        .tool-group {
            display: flex;
            gap: 5px;
            padding-right: 20px;
            border-right: 1px solid var(--border);
            align-items: center;
        }

        .tool-group:last-child {
            border-right: none;
        }

        .btn-tool {
            background: transparent;
            border: 1px solid transparent;
            color: #94a3b8;
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .btn-tool:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
        }

        .btn-tool.active {
            background: rgba(59, 130, 246, 0.2);
            color: var(--accent);
            border-color: rgba(59, 130, 246, 0.5);
        }

        .btn-primary {
            background: var(--accent);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 500;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: #94a3b8;
        }

        .export-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }

        select {
            background: var(--bg-dark);
            color: var(--text-light);
            border: 1px solid var(--border);
            padding: 6px 10px;
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.9rem;
        }

        /* --- Workspace --- */
        .workspace {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
            background-color: #334155;
        }

        .ruler-h {
            position: absolute;
            top: 0;
            left: 40px;
            /* Width of vertical ruler */
            right: 0;
            height: 30px;
            background: var(--ruler-bg);
            border-bottom: 1px solid #cbd5e1;
            z-index: 10;
            overflow: hidden;
        }

        .ruler-v {
            position: absolute;
            top: 30px;
            /* Height of horizontal ruler */
            left: 0;
            bottom: 0;
            width: 40px;
            background: var(--ruler-bg);
            border-right: 1px solid #cbd5e1;
            z-index: 10;
            overflow: hidden;
        }

        .scroll-container {
            position: absolute;
            top: 30px;
            left: 40px;
            right: 0;
            bottom: 0;
            overflow: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px;
            gap: 40px;
            /* Gap between pages */
        }

        /* --- Page --- */
        .page {
            background: var(--bg-paper);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            position: relative;
            /* Dimensions set by JS based on zoom */
            transform-origin: top center;
            transition: transform 0.1s ease-out;
        }

        .page-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
            /* Allow clicking through to text */
        }

        .page-content {
            width: 100%;
            height: 100%;
            position: relative;
            outline: none;
            color: black;
            font-family: 'Times New Roman', serif;
            overflow: hidden;
            z-index: 1;
            /* Above canvas */
        }

        /* Semantic Elements Styles for Editor */
        .page-content p,
        .page-content h1,
        .page-content h2,
        .page-content h3 {
            margin-bottom: 0;
            line-height: 1.2;
            position: absolute;
            white-space: pre;
            cursor: text;
            background-color: #ffffff;
            box-shadow: 0 0 0 3px #ffffff;
            /* Halo to mask underlying text */
            border-radius: 2px;
            z-index: 10;
            padding: 0 1px;
        }

        .page-content h1,
        .page-content h2,
        .page-content h3 {
            font-weight: bold;
        }

        /* Selection & Focus */
        .page-content *:focus {
            outline: 2px solid rgba(59, 130, 246, 0.3);
            background: rgba(59, 130, 246, 0.1);
            z-index: 10;
        }

        /* --- Overlays --- */
        .loader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 23, 42, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .loader-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--accent);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .progress-bar {
            width: 300px;
            height: 6px;
            background: #334155;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.3s ease;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* --- Helpers --- */
        .hidden {
            display: none !important;
        }

        /* File Input */
        #fileInput {
            display: none;
        }

        /* Status Bar */
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 25px;
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            align-items: center;
            font-size: 0.75rem;
            color: #94a3b8;
            z-index: 60;
        }
    </style>
</head>

<body>

    <!-- Toolbar -->
    <div class="toolbar">
        <a href="index.html" class="brand">
            <i class="fa-solid fa-arrow-left"></i>
            <span>PDF Pro</span>
        </a>

        <div class="tool-group">
            <button class="btn-tool" onclick="document.getElementById('fileInput').click()" title="Abrir PDF">
                <i class="fa-solid fa-folder-open"></i>
            </button>
            <button class="btn-tool" onclick="editor.saveProject()" title="Guardar Progreso">
                <i class="fa-solid fa-floppy-disk"></i>
            </button>
            <input type="file" id="fileInput" accept=".pdf">
        </div>

        <div class="tool-group">
            <button class="btn-tool" onclick="editor.undo()" title="Deshacer (Ctrl+Z)">
                <i class="fa-solid fa-rotate-left"></i>
            </button>
            <button class="btn-tool" onclick="editor.redo()" title="Rehacer (Ctrl+Y)">
                <i class="fa-solid fa-rotate-right"></i>
            </button>
        </div>

        <div class="tool-group">
            <button class="btn-tool" onclick="editor.format('bold')" title="Negrita">
                <i class="fa-solid fa-bold"></i>
            </button>
            <button class="btn-tool" onclick="editor.format('italic')" title="Cursiva">
                <i class="fa-solid fa-italic"></i>
            </button>
            <button class="btn-tool" onclick="editor.format('underline')" title="Subrayado">
                <i class="fa-solid fa-underline"></i>
            </button>
        </div>

        <div class="tool-group zoom-controls">
            <button class="btn-tool" onclick="editor.setZoom(editor.zoom - 0.1)">
                <i class="fa-solid fa-minus"></i>
            </button>
            <span id="zoomLevel">100%</span>
            <button class="btn-tool" onclick="editor.setZoom(editor.zoom + 0.1)">
                <i class="fa-solid fa-plus"></i>
            </button>
        </div>

        <div style="flex: 1;"></div>

        <div class="export-controls">
            <select id="exportMode">
                <option value="visual">Modo Visual (Imagen Exacta)</option>
                <option value="vector">Modo Vectorial (Texto Seleccionable)</option>
            </select>
            <button class="btn-primary" onclick="exporter.exportPDF()">
                <i class="fa-solid fa-file-export"></i> Exportar
            </button>
        </div>
    </div>

    <!-- Workspace -->
    <div class="workspace">
        <div class="ruler-h" id="rulerH"></div>
        <div class="ruler-v" id="rulerV"></div>

        <div class="scroll-container" id="scrollContainer">
            <div id="pagesContainer">
                <!-- Pages will be injected here -->
                <div class="empty-state" style="text-align: center; color: #64748b; margin-top: 100px;">
                    <i class="fa-solid fa-file-pdf" style="font-size: 64px; margin-bottom: 20px;"></i>
                    <h2>No hay documento cargado</h2>
                    <p>Sube un PDF para comenzar a editar</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <span id="statusText">Listo</span>
        <span id="pageInfo">Página 0 de 0</span>
    </div>

    <!-- Loader -->
    <div class="loader-overlay" id="loader">
        <div class="loader-spinner"></div>
        <h3 id="loaderText" style="color: white; margin-bottom: 10px;">Procesando...</h3>
        <div class="progress-bar">
            <div class="progress-fill" id="progressBar"></div>
        </div>
    </div>

    <script>
        // --- Constants & Config ---
        const CONFIG = {
            DPI: 96,
            MM_TO_PX: 3.7795275591, // 1mm in px at 96 DPI
            PT_TO_MM: 0.352778,     // 1pt in mm
            A4_WIDTH_MM: 210,
            A4_HEIGHT_MM: 297
        };

        // --- Core Logic: PDF Processor ---
        class PDFProcessor {
            constructor() {
                this.pdfDoc = null;
            }

            async loadFile(file) {
                const arrayBuffer = await file.arrayBuffer();
                this.pdfDoc = await pdfjsLib.getDocument(arrayBuffer).promise;
                return this.pdfDoc.numPages;
            }

            async extractPage(pageNum) {
                const page = await this.pdfDoc.getPage(pageNum);
                const viewport = page.getViewport({ scale: 1.0 }); // Base scale
                const textContent = await page.getTextContent();

                const widthPt = viewport.width;
                const heightPt = viewport.height;

                const items = textContent.items.map(item => {
                    const x_pt = item.transform[4];
                    const y_pt = item.transform[5];
                    const fontHeight_pt = Math.sqrt(item.transform[0] * item.transform[0] + item.transform[1] * item.transform[1]);

                    const x_mm = x_pt * CONFIG.PT_TO_MM;
                    const y_mm = (heightPt - y_pt) * CONFIG.PT_TO_MM - (fontHeight_pt * CONFIG.PT_TO_MM);

                    const fontSize_pt = fontHeight_pt;

                    return {
                        str: item.str,
                        x: x_mm,
                        y: y_mm,
                        fontSize: fontSize_pt,
                        fontName: item.fontName,
                        width: item.width * CONFIG.PT_TO_MM,
                        height: item.height * CONFIG.PT_TO_MM,
                        hasEOL: item.hasEOL
                    };
                });

                return {
                    blocks: this.processItems(items),
                    page: page // Return page object for canvas rendering
                };
            }

            processItems(items) {
                items.sort((a, b) => {
                    if (Math.abs(a.y - b.y) > 1) return a.y - b.y;
                    return a.x - b.x;
                });

                const blocks = [];
                let currentBlock = null;

                items.forEach(item => {
                    if (!item.str.trim()) return;

                    // Check if same line (y similar)
                    const sameLine = currentBlock && Math.abs(item.y - currentBlock.y) < 2;

                    // Check horizontal distance (for tables/columns)
                    // If distance > 5mm, treat as separate block even if on same line
                    const isFar = currentBlock && (item.x - (currentBlock.x + currentBlock.width)) > 5;

                    if (sameLine && !isFar) {
                        const space = item.x - (currentBlock.x + currentBlock.width);
                        if (space > 1) currentBlock.text += " ";
                        currentBlock.text += item.str;
                        currentBlock.width += item.width + (space > 0 ? space : 0);
                    } else {
                        if (currentBlock) blocks.push(currentBlock);
                        currentBlock = {
                            text: item.str,
                            x: item.x,
                            y: item.y,
                            fontSize: item.fontSize,
                            fontName: item.fontName,
                            width: item.width,
                            type: 'p'
                        };

                        if (item.fontSize > 14) currentBlock.type = 'h1';
                        else if (item.fontSize > 12) currentBlock.type = 'h2';
                    }
                });
                if (currentBlock) blocks.push(currentBlock);

                return blocks;
            }
        }

        // --- Editor Logic ---
        class Editor {
            constructor() {
                this.zoom = 1.0;
                this.pages = [];
                this.history = [];
                this.historyIndex = -1;
                this.container = document.getElementById('pagesContainer');
                this.processor = new PDFProcessor();
            }

            async loadPDF(file) {
                ui.showLoader(true, "Leyendo PDF...");
                try {
                    const numPages = await this.processor.loadFile(file);
                    this.container.innerHTML = '';
                    this.pages = [];

                    for (let i = 1; i <= numPages; i++) {
                        ui.updateProgress((i / numPages) * 100);
                        const { blocks, page } = await this.processor.extractPage(i);
                        await this.renderPage(i, blocks, page);
                    }

                    this.saveState();
                    ui.setStatus(`Cargado exitosamente: ${numPages} páginas`);
                } catch (e) {
                    console.error(e);
                    alert("Error al cargar PDF: " + e.message);
                } finally {
                    ui.showLoader(false);
                }
            }

            async renderPage(pageNum, blocks, pdfPage) {
                const pageDiv = document.createElement('div');
                pageDiv.className = 'page';
                pageDiv.dataset.page = pageNum;

                const wPx = CONFIG.A4_WIDTH_MM * CONFIG.MM_TO_PX;
                const hPx = CONFIG.A4_HEIGHT_MM * CONFIG.MM_TO_PX;

                pageDiv.style.width = `${wPx}px`;
                pageDiv.style.height = `${hPx}px`;
                pageDiv.style.marginBottom = '40px';

                // 1. Render PDF Background to Canvas
                const canvas = document.createElement('canvas');
                canvas.className = 'page-canvas';
                canvas.width = wPx;
                canvas.height = hPx;

                // We need to render at high quality then scale down via CSS if needed, 
                // but here we match 1:1 with editor pixels (which is 96 DPI approx)
                // Actually, for better quality on retina, we might want 2x, but let's stick to 1x for performance first.
                // To match dimensions:
                const viewport = pdfPage.getViewport({ scale: wPx / pdfPage.getViewport({ scale: 1 }).width });

                await pdfPage.render({
                    canvasContext: canvas.getContext('2d'),
                    viewport: viewport
                }).promise;

                pageDiv.appendChild(canvas);

                // 2. Render Editable Text Overlay
                const contentDiv = document.createElement('div');
                contentDiv.className = 'page-content';
                contentDiv.contentEditable = true;

                blocks.forEach(block => {
                    const el = document.createElement(block.type);
                    el.textContent = block.text;

                    el.style.position = 'absolute';
                    el.style.left = `${block.x * CONFIG.MM_TO_PX}px`;
                    el.style.top = `${block.y * CONFIG.MM_TO_PX}px`;
                    el.style.fontSize = `${block.fontSize}pt`;

                    if (block.fontName.toLowerCase().includes('bold')) el.style.fontWeight = 'bold';
                    if (block.fontName.toLowerCase().includes('italic')) el.style.fontStyle = 'italic';

                    contentDiv.appendChild(el);
                });

                pageDiv.appendChild(contentDiv);
                this.container.appendChild(pageDiv);
                this.pages.push(pageDiv);

                contentDiv.addEventListener('input', () => this.debounceSave());
            }

            setZoom(level) {
                this.zoom = Math.max(0.5, Math.min(2.0, level));
                document.getElementById('zoomLevel').textContent = `${Math.round(this.zoom * 100)}%`;

                this.container.style.transform = `scale(${this.zoom})`;
                this.container.style.transformOrigin = 'top center';
            }

            format(command, value = null) {
                document.execCommand(command, false, value);
                this.saveState();
            }

            // History System
            saveState() {
                // Limit history
                if (this.history.length > 50) this.history.shift();

                // Remove future states if we are in middle
                if (this.historyIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.historyIndex + 1);
                }

                // Serialize content
                const state = this.pages.map(p => p.querySelector('.page-content').innerHTML);
                this.history.push(state);
                this.historyIndex++;
            }

            debounceSave() {
                clearTimeout(this.saveTimeout);
                this.saveTimeout = setTimeout(() => this.saveState(), 1000);
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.restoreState(this.history[this.historyIndex]);
                }
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.restoreState(this.history[this.historyIndex]);
                }
            }

            restoreState(state) {
                if (!state) return;
                this.pages.forEach((page, index) => {
                    if (state[index]) {
                        page.querySelector('.page-content').innerHTML = state[index];
                    }
                });
            }

            saveProject() {
                localStorage.setItem('pdf_project_autosave', JSON.stringify(this.history[this.historyIndex]));
                ui.setStatus("Guardado en navegador");
            }
        }

        // --- Exporter Logic ---
        class Exporter {
            async exportPDF() {
                const mode = document.getElementById('exportMode').value;

                if (mode === 'visual') {
                    await this.exportVisual();
                } else {
                    await this.exportVector();
                }
            }

            async exportVisual() {
                ui.showLoader(true, "Generando PDF Visual (Alta Fidelidad)...");
                try {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF({
                        orientation: 'portrait',
                        unit: 'mm',
                        format: 'a4'
                    });

                    const pages = document.querySelectorAll('.page');

                    for (let i = 0; i < pages.length; i++) {
                        if (i > 0) doc.addPage();

                        const page = pages[i];
                        // Capture at high scale for quality
                        const canvas = await html2canvas(page, {
                            scale: 2,
                            useCORS: true,
                            logging: false
                        });

                        const imgData = canvas.toDataURL('image/jpeg', 0.95);
                        doc.addImage(imgData, 'JPEG', 0, 0, 210, 297);
                        ui.updateProgress(((i + 1) / pages.length) * 100);
                    }

                    doc.save("documento_visual.pdf");
                    ui.setStatus("PDF Visual Exportado");
                } catch (e) {
                    console.error(e);
                    alert("Error exportando visual: " + e.message);
                } finally {
                    ui.showLoader(false);
                }
            }

            async exportVector() {
                ui.showLoader(true, "Generando PDF Vectorial...");
                try {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF({
                        orientation: 'portrait',
                        unit: 'mm',
                        format: 'a4'
                    });

                    const pages = document.querySelectorAll('.page');

                    for (let i = 0; i < pages.length; i++) {
                        if (i > 0) doc.addPage();

                        const page = pages[i];
                        const canvas = page.querySelector('canvas');
                        const content = page.querySelector('.page-content');

                        // 1. Add Background Image (Canvas)
                        if (canvas) {
                            const bgData = canvas.toDataURL('image/jpeg', 0.8);
                            doc.addImage(bgData, 'JPEG', 0, 0, 210, 297);
                        }

                        // 2. Add Vector Text Overlay
                        const elements = content.children;

                        for (let el of elements) {
                            const style = window.getComputedStyle(el);
                            const text = el.textContent;

                            const x_mm = parseFloat(style.left) / CONFIG.MM_TO_PX;
                            const y_mm = parseFloat(style.top) / CONFIG.MM_TO_PX;

                            const fontSize_pt = parseFloat(style.fontSize);
                            doc.setFontSize(fontSize_pt);

                            const isBold = parseInt(style.fontWeight) >= 600 || style.fontWeight === 'bold';
                            const isItalic = style.fontStyle === 'italic';

                            doc.setFont("helvetica", isBold && isItalic ? "bolditalic" : isBold ? "bold" : isItalic ? "italic" : "normal");

                            const baselineOffset = (fontSize_pt * 0.352778) * 0.8;

                            // To mimic the white background masking, we could draw a white rect behind text
                            // doc.setFillColor(255, 255, 255);
                            // doc.rect(x_mm, y_mm, width_mm, height_mm, 'F');
                            // But calculating exact width/height is tricky without font metrics.
                            // For now, we just draw text on top. If user deleted text, the background text remains...
                            // Wait, if user DELETES text, they expect it gone.
                            // BUT we are rendering the ORIGINAL PDF as background.
                            // So if they delete text in editor, the ORIGINAL text shows through!
                            // This is a fundamental limitation of "Background Image" approach.
                            // To fix this, we need to "White Out" the area where text WAS.
                            // But we don't know where original text was if we only have current DOM.

                            // However, the user wants "lines" (signatures, tables).
                            // The editable text has white background in CSS.
                            // So in Editor, it looks fine.
                            // In Export, we need to replicate that "White Background" for the text box.

                            const textWidth = doc.getTextWidth(text);
                            const textHeight = fontSize_pt * 0.352778;

                            doc.setFillColor(255, 255, 255);
                            // Draw a white rect behind the new text to mask the old text
                            doc.rect(x_mm, y_mm, textWidth + 1, textHeight + 1, 'F'); // +1 padding

                            doc.setTextColor(0, 0, 0);
                            doc.text(text, x_mm, y_mm + baselineOffset);
                        }
                    }

                    doc.save("documento_vectorial.pdf");
                    ui.setStatus("PDF Vectorial Exportado");

                } catch (e) {
                    console.error(e);
                    alert("Error exportando vectorial: " + e.message);
                } finally {
                    ui.showLoader(false);
                }
            }
        }

        // --- UI Helpers ---
        const ui = {
            loader: document.getElementById('loader'),
            loaderText: document.getElementById('loaderText'),
            progressBar: document.getElementById('progressBar'),
            statusText: document.getElementById('statusText'),

            showLoader(show, text = "") {
                this.loader.style.display = show ? 'flex' : 'none';
                if (text) this.loaderText.textContent = text;
                this.progressBar.style.width = '0%';
            },

            updateProgress(percent) {
                this.progressBar.style.width = `${percent}%`;
            },

            setStatus(text) {
                this.statusText.textContent = text;
                setTimeout(() => this.statusText.textContent = "Listo", 3000);
            }
        };

        // --- Initialization ---
        const editor = new Editor();
        const exporter = new Exporter();

        document.getElementById('fileInput').addEventListener('change', (e) => {
            if (e.target.files[0]) editor.loadPDF(e.target.files[0]);
        });

        // Initialize Rulers (Visual only for now)
        function initRulers() {
            const hRuler = document.getElementById('rulerH');
            // Draw ticks every 10mm
            for (let i = 0; i < 210; i += 10) {
                const tick = document.createElement('div');
                tick.style.position = 'absolute';
                tick.style.left = `${i * CONFIG.MM_TO_PX}px`;
                tick.style.height = '100%';
                tick.style.borderLeft = '1px solid #cbd5e1';
                tick.style.fontSize = '10px';
                tick.style.paddingLeft = '2px';
                tick.textContent = i;
                hRuler.appendChild(tick);
            }
        }
        initRulers();

    </script>
</body>

</html>